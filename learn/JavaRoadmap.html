<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="GENERATOR" content="JustSystems Homepage Builder Version 21.0.5.0 for Windows">
<title>学習テーマ</title>
</head>
<body style="margin:20px;">
<p><a href="../index.html">NEXTDesign</a></p>

<h1>Javaプログラミング入門</h1>

更新 2025.8.30 NEXTDesign

<h2 style="background-color:skyblue ;">&nbsp;Java 学習ロードマップ</h2>

<p>このロードマップは、プログラミング未経験の方やJava入門者の方が自習する際の道しるべです。<br>
設計やテストについても習得することを目指します。</p>

<ol>
  <li>情報技術の基礎
  <ul>
     <li><a href="JavaRoadmap-離散数学.html" target="_blank">コンピュータ科学</a>
  </ul>

  <li>プログラミング環境を準備します <br>プログラムを作成するためには統合開発環境（IDE）というソフトウェアを使用します。まず最初に自分のPCにIDEをインストールします。 
  <br>本テキストでは Pleiades All in One Eclipse を使用しています。
  <br><a href="docs/IDE.pdf" target="_new">インストールとカスタマイズの例</a>

  <br>他のIDEの例
  <ul>
    <li>Eclipse
    <li>Spring Tools 4 for Eclipse
    <li>Spring Tools 4 for Visual Studio Code
    <li>IntelliJ IDEA
    <li>Visual Studio Code （VSCode）
    </ul>
Maven/Gradleプロジェクトであれば基本的にどのIDEでもインポート可能です。<br>
しかし、IDE独自の設定ファイルの互換性は低いです。<br>
Eclipseの project, .classpath<br>
IntelliJ IDEAの.idea, .iml<br>
VSCodeの .vscode<br>

    <br>

    <li>小さなプログラムを作成し動かしてみます
    <ul>
    <li>プログラムを作成します<br>（「Eclipse Helloworld」でGoogle検索してみてください）
    <li>プログラムを動かします
    <li><a href="codes/HelloWorld.html" target="_new2">HelloWorld</a>
    <li>実行とデバッグ実行
    <li><a href="docs/WriteOnceRunAnywhere.pdf" target="_new">HelloWorldが動くまでの仕組み</a>
    </ul>

    <li>アルゴリズムとデータ構造
    <ul>
    <li><a href="docs/FlowChart.pdf" target="_new">フローチャートとは</a>
    <li>１列に並んだ1～10までの番号札を、小さい順に並べるプログラムを作成する 
    <li><a href="docs/AlgorithmsAndDataStructures.pdf" target="_new2">アルゴリズムやデータ構造の例</a>
    </ul>
<br>

    <li>関連する概念・用語
  <ul>
    <li>メッセージ
    <li>メソッド
    <li>ロジック
    <li>パターン
    </ul>


  <li>Java
<ul>
    <li><a href="docs/FeaturesOfOOPAndJava.pdf" target="">Javaの特徴</a>
    <li><a href="JDK.html" target="_new2">Javaのバージョン</a>
    <li>Javaプログラムの構造
    <li><a href="codes/Person.html" target="_new2">Javaコードの例</a>
    <li>命名規則と予約語
    <li>変数とデータ型
    <li>リテラルと定数
    <li>式と演算子
    <li>制御文
    <li>メソッド
    <li>メソッドとは
    <li>定義する
    <li>使用する（呼び出す）
    <li>文とブロック
    <li>変数
    <li>型
    <li>リテラル
    <li>演算子
    <li>制御文
      <ul>
      <li>分岐
      <li>繰り返し
      </ul>
    <li>スコープ
    <li>クラス 宣言<li>メソッド 宣言<li>修飾子
    <li>メソッドのオーバーロード
    <li>mainメソッド    <li>インスタンス
    <li>this
    <li><a href="docs/コンストラクタとイニシャライザ.pdf" target="_new">コンストラクタとイニシャライザ</a>
    <li>Javadoc
	<ul>
	<li>アノテーション
	</ul>
    <li>命名
    <li>型
      <ul>
      <li>プリミティブ型
      <li>参照型
      <li>ラッパークラス
      <li>オートボクシング・アンボクシング
      </ul>
    <li>クラス定義
      <ul>
      <li>パッケージ
      <li>修飾子
      <li>継承
      <li>抽象クラス
      <li>インタフェース
      <li>匿名クラス
      </ul>
    <li>型判定
    <li>同一性と等価性
    <li><a href="docs/Enumとenum.pdf" target="_new">列挙型（Enumとenum）</a>
    <li>ジェネリクス（総称型）
    <li>配列
    <ul>
      <li>配列とは
      <li>配列と繰り返し
      <li>多次元配列
    </ul>
    <li>コレクション
    <li>List
    <li>Map
    <li>Set
    <li>ストリーム
    <ul>
      <li>ラムダ式
      <li>StreamAPI
      <li>Streamの作成
      <li>Streamの中間処理
      <li>Streamの終端処理
    </ul>
    <li>例外
    <li>文字列操作
    <li>正規表現
    <li>ファイル操作
    <li>日付 操作
<br>
    <br></ul>
  
  <li>データベース アクセス <br>Java で RDB（MySQL, PostgreSQL など）を扱う際には、抽象化レベルや開発効率に応じていくつかの選択肢があります。
大きく分けると「生の SQL を使う」か「抽象化レイヤーを使う」か、になります。<br><br>
  <ul>
<li>選択肢① SQL 直利用
    <ul>
	<li>Java標準 JDBC (Java Database Connectivity)
		<ul>
		<li>抽象化レベル：低
		<li>概要
		<br>Java 標準の API。RDB と接続して SQL を直接発行する。
		<li>特徴
			<ul>
			<li>すべての操作を自分で SQL で書く。
			<li>接続管理（Connection）、SQL 実行（Statement / PreparedStatement）、結果取得（ResultSet）をハンドリング。
			</ul>
		<li>メリット
			<ul>
			<li>軽量で依存が少ない
。			<li>SQL を完全に制御できる。
			</ul>
		<li>デメリット
			<ul>
			<li>冗長なコード（例: try-catch-finally の多用）。
			<li>オブジェクトとテーブルのマッピングを自分で実装する必要がある。
			</ul>
		</ul>
	</ul>
</ul>
<br>
<!--  ########################## -->
<ul>
<li>選択肢②  SQL マッピング系
    <ul>
	<li>抽象化レベル：中
	<li>Spring JDBC
      <ul>
        <li>概要
	<br>JDBC をラップして便利にしたもの（Spring Framework）。 
		<li>特徴
			<ul>
			<li>JdbcTemplate で接続・リソース解放処理を簡略化。
			<li>依然として SQL を自分で書くが、例外処理やマッピングがシンプルになる。
			</ul>
		</ul>
	</ul>
	<ul>
	<li>MyBatis
      <ul>
		<li>概要
		<br>SQL マッピングフレームワーク。 
		<li>特徴
		<ul>
			<li>SQL は XML やアノテーションに定義。
        			<li>SQL とオブジェクトのマッピングを自動化。
     		</ul>
		<li>メリット
			<ul>
			<li>SQL の自由度が高い（チューニングしやすい）。
			 </ul>
		<li>デメリット
			<ul>
			<li>大規模開発では SQL 管理が煩雑になる場合あり。
       		 </ul>
		</ul>
	</ul>
</ul>
<br>
<!--  ########################## -->
<ul>
<li>選択肢③ O/R マッピング (ORM)
    <ul>
	<li>Java標準ORM JPA (Java Persistence API)
      	<ul>
		<li>抽象化レベル：高
		<li>概要
			<ul>
			<li>Java 標準の ORM API（インタフェース仕様）。
        			<li>実装として Hibernate や EclipseLink が有名。				
        			</ul>
		<li>特徴
			<ul>
			<li>@Entity を付けたクラスをテーブルにマッピング。
			<li>EntityManager を使って永続化、検索、更新、削除を行う。
			<li>SQL ではなく JPQL (Java Persistence Query Language) を使用可能。
			</ul>
		<li>メリット
			<ul>
			<li>ドメインモデルとデータベースの整合性を保ちやすい。
			<li>生 SQL を書かなくても CRUD ができる。
			</ul>
		<li>デメリット
			<ul>
			<li>学習コストが高い。
          			<li>複雑な SQL チューニングには不向き。
        			</ul>
		</ul>
	</ul>
<li>補助的な選択肢
    <ul>
	<li>jOOQ
      	<ul>
		<li>概要
			<ul>
			<li>タイプセーフな SQL DSL を提供するフレームワーク
        			</ul>
		<li>特徴
			<ul>
			<li>SQL をコードで書ける（Java の型チェックが効く）
			<li>DB の方言(Dialect)毎の SQL を自動生成。
			</ul>
		<li>メリット
			<ul>
			<li>SQL 主体だが型安全性が高い。
			</ul>
		<li>デメリット
			<ul>
			<li>JPA 程の ORM ではない。
        			</ul>
		</ul>
	</ul>

<li>まとめ
	<ul>
	<li>SQL を完全に書きたい → JDBC, Spring JDBC, MyBatis, jOOQ
	<li>SQL をなるべく書きたくない／ドメインモデル重視 → JPA
	<li>両立したい → MyBatis + Spring Boot, あるいは jOOQ
	</ul>
<li>よく使われる選択肢
	<ul>
	<li>小規模／SQL 主体 → Spring JDBC or MyBatis
	<li>中～大規模／ドメイン駆動 → JPA
	<li>SQL の制御を強めつつ型安全に → jOOQ
	</ul>

</ul>
<!--  ########################## -->
<br>

  <li>JPA 
<p>
JPA（Java Persistence API）は、Javaアプリケーションでデータベースとの連携を簡単に行うための標準仕様です。
Javaオブジェクトとリレーショナルデータベース（RDB）の間のデータのやり取りをスムーズにするための仕組み（O/Rマッピング）を提供します。 
</p>
<p>
JPAの目的とメリット<br>
JPAの主な目的は、開発者が煩雑なSQL文を直接書く手間を減らし、Javaの「オブジェクト」を中心とした開発に集中できるようにすることです。 
SQLの記述量を削減: 特にデータの作成・読み込み・更新・削除（CRUD）といった基本的な操作のSQL文を自動化できます。
データベースへの依存を軽減: JPAの仕様に則って開発すれば、特定のデータベース製品（MySQL, PostgreSQL, Oracleなど）に依存する度合いが減り、異なるDBへの移行が容易になります。
オブジェクト指向的な開発: データベースのテーブルではなく、Javaのクラス（エンティティ）を操作対象として扱えるため、アプリケーション開発の生産性と保守性が向上します。 
</p>
<p>
JPAの主な構成要素<br>
JPAを理解する上で重要な概念は以下の通りです。
エンティティ (Entity): データベースのテーブルに対応するJavaのクラス（POJO）です。特定のJPAアノテーション（例：@Entity, @Id, @Columnなど）を付与することで、どのクラスがどのテーブルにマッピングされるかを定義します。
永続化コンテキスト (Persistence Context): エンティティのライフサイクル（生成、取得、更新、削除）を管理する領域です。データベースとの実際のやり取りはこのコンテキストを介して行われます。
EntityManager: 永続化コンテキストを通じてエンティティの操作（保存、検索、更新など）を行うための主要なインターフェースです。
JPQL (Java Persistence Query Language): SQLに似ていますが、テーブルではなくエンティティを対象としたクエリ言語です。これにより、データベースの種類に依存しないクエリを記述できます。 
</p>
<p>
実装とフレームワーク<br>
JPAはあくまで「仕様」であり、実際に動作させるにはその仕様に基づいた実装ライブラリが必要です。代表的な実装にはHibernateなどがあります。 
また、Spring Data JPA のようなフレームワークと組み合わせることで、さらに少ないコード量でJPAを利用できるようになり、Spring BootなどのモダンなJava開発環境で広く利用されています

</p>
 <!-- 
  <ul>
<li>ネイティブSQL
Manager#createNativeQuery(String)を使用する。
<pre>
<code>
        List User  results = entityManager
            .createNativeQuery("select * from user where name = :name", User.class)
            .setParameter("name", "きい太")
            .getResultList();
</code>
</pre>

<li>JPQL
<li>CriteriaAPI
<li>名前付きクエリ
<li>JPAプロバイダの機能を直接使用する</ul>
 -->
    <br>
  
  <li>開発プロセス
  <ul>
    <li>設計（調査・分析・基本設計・プログラム設計）    
      <ul>
      <li>ウォーターフォール
      <li>アジャイル
      </ul>
    <li>テスト計画・テスト実施
      <ul>
      <li>JUnit
      </ul>
    <li>ドキュメンテーション
      <ul>
      <li>UML
      <li>プロジェクト独自
      </ul>
    <li><a href="docs/SampleOfSystemDesignDocument.pdf" target="_new2">ドキュメントの例</a>
</ul>



<!-- 
<li>分析・設計・モデリング ～ さらなるステップアップ 
    <ul>
    <li><a href="index.html#course2">オブジェクト指向技術</a>
    <li><a href="index.html#course3">ドメイン駆動設計</a>
    </ul>
-->


</ol>

<br>
</body>
</html>